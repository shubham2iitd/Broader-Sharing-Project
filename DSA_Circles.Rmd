
```{r}
library(data.table)
library(Matrix)
library(gurobi)
library(readxl)

library(mltools)
library(ggplot2)
```


```{r}
computer = "imac" # mac, imac, windows

if (computer == "imac") {
  fol = paste0("/Users/sakshat/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "/Users/sakshat/Google Drive/"
} else if (computer == "mac") {
  fol = paste0("/Users/shubham/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "/Users/shubham/Google Drive/"
} else if (computer == "windows") {
  fol = paste0("C:/Users/sakshat/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "C:/Users/sakshat/Google Drive/"
}
```

```{r}
can_pool_master = read.csv(paste0(fol, "/can_pool_master_2yrs_5000_pats.csv"), stringsAsFactors = F)
don1 = read.csv(paste0(fol, "/don1_3600.csv"), stringsAsFactors = F)

df_dem_sup = data.table(can_pool_master)[, list(dem = uniqueN(PX_ID)), by = list(CAN_OPO_CD)]
temp = data.table(don1)[, list(sup = uniqueN(DONOR_ID)), by = list(DON_OPO_CTR_CD)]
temp = temp[!temp$DON_OPO_CTR_CD %in% c("ZCAN", "WISE")]    # sum(temp$sup)
  
df_dem_sup = merge(df_dem_sup, temp, by.x = "CAN_OPO_CD", by.y = "DON_OPO_CTR_CD", all.y = T)
colnames(df_dem_sup)[1] = "DSA"
```


```{r}
#df_dem_sup = read_excel("opo_donor_candidate2.xlsx")    # Demand-supply data    


# df_opo_time = read.csv('adjacency_time.csv')    # Transplant Volume weighted transport time between DSAs
#df_opo_time = read.csv(paste0(fol_, '/Optimized Overlapping Organ Allocation/travel_time_HIOP_PRLL_mod.csv'))    # Transplant Volume weighted transport time between DSAs, have modified for HIOP & PRLL
#df_opo_time = df_opo_time[-1, -c(1,3)]   # So as to make similar data structures for 'df_opo_time' and 'df_opo_dist'

# In "miles" as dist(AROR(TC:ARUA), DCTC(TC:DCGU))=905, As per google, driving dist is 1013 miles, Similarly, dist(NYFL(TC:NYFL), NEOR(TC:NEUN))=1052, As per google, driving dist is 951 miles
df_opo_dist = read_excel(paste0(fol_, '/Health Care/Optimized Overlapping Organ Allocation/opo_distances_populationweighted.xlsx'), sheet=2)    # Transplant Volume weighted transport distance between DSAs      # SHEET=2 has distances modified or HIOP and PRLL!!!
df_opo_dist = data.frame(df_opo_dist)   
df_opo_dist = df_opo_dist[-1, -c(2, ncol(df_opo_dist))]
df_opo_adj = read_excel(paste0(fol_, '/Health Care/Optimized Overlapping Organ Allocation/adjacency_boundary_HIOP_PRLL_mod.xlsx'), sheet=1)    # Contains boundary adjacency among DSAs,  have modified for HIOP & PRLL
df_opo_adj = df_opo_adj[-1, -c(2)]
df_opo_adj = as.data.frame(df_opo_adj)
df_opo_adj[df_opo_adj[, 1] == "CTHH", 1] = "CTOP"
colnames(df_opo_adj)[which(colnames(df_opo_adj) == "CTHH")] = "CTOP"
```

```{r}
# Replace "CTHH" with "CTOP":
#df_opo_time[, 1] = as.character(df_opo_time[, 1])
#df_opo_time[df_opo_time[, 1] == "CTHH", 1] = "CTOP"
#colnames(df_opo_time)[which(colnames(df_opo_time) == "CTHH")] = "CTOP"

df_opo_dist[, 1] = as.character(df_opo_dist[, 1])
df_opo_dist[df_opo_dist[, 1] == "CTHH", 1] = "CTOP"
colnames(df_opo_dist)[which(colnames(df_opo_dist) == "CTHH")] = "CTOP"
```


```{r}
df_sup = as.data.frame(df_dem_sup[, c("DSA", "sup")])

df_dem = as.data.frame(df_dem_sup[!is.na(df_dem_sup$dem), c("DSA", "dem")])     # Demand column is : "incident_15_1317"

sum(df_sup$sup); sum(df_dem$dem)
```

```{r}
#df_opo_time = df_opo_time[df_opo_time[, 1] %in% df_sup[, 1], ]
#df_opo_time = df_opo_time[, c("OPO_ID.x", df_dem[, 1])]

df_opo_dist = df_opo_dist[df_opo_dist[, 1] %in% df_sup[, 1], ]
df_opo_dist = df_opo_dist[, c("OPO_ID.x", df_dem[, 1])]
#c("NYWN", "NYAP", "CAGS", "OHLC", "NVLV", "NMOP")
```

```{r}
# Specify limiting measure: Distance OR Time:

mea = "dist" # Either "dist" or "time".
val = 650 

if (mea == "dist") {
  max_rad = val * 1.15078   # 1.15078 is multiplied to convert into miles from Nautical miles.
  df_mea = df_opo_dist
  
  # # Remove HIOP and PRLL:
  # df_dem = df_dem[]
  
} else if (mea == "time") {
  max_rad = val   # In hrs.
  df_mea = df_opo_time
}
```

# TO impose 'minimum transplant center'(=3) in neighbourhood constraint:
```{r}
SKIP for now:
TC_cnt = read.csv("Files_JHU/zip_transplant.csv", stringsAsFactors = FALSE)
uniqueN(TC_cnt[, 2])  # In addition to 6 OPOs with 0 demand, HIOP and PRLL doesn't seem to have any transplant centers!
TC_cnt = data.table(TC_cnt[, c("transplant_center", "OPO")])[, list(TC_count = .N), by = OPO]
TC_cnt = rbind(TC_cnt, list("NYWN", 0), list("NYAP", 0), list("CAGS", 0), list("OHLC", 0), list("NVLV", 0), list("NMOP", 0), 
               list("HIOP", 0), list("PRLL", 0))

min_dist = 150 * 1.15078 # NAUTICAL miles * 1.15078, # Dataframe 'TC_cnt' doesnot contain: "HIOP" and "PRLL".
n = 3  # Minimum TCs in a neighbourhood

TC_cnt$min_dist_miles_n_TCs = 0
for (opo in c(TC_cnt$OPO)) {
  if (mea == "dist") {    
    temp = as.data.frame(t(df_mea[as.character(df_mea[, 1]) == as.character(opo), ])[-1, ])
    temp[, 1] = as.numeric(as.character(temp[, 1]))
    temp[, 2] = row.names(temp)
    temp = merge(temp, TC_cnt[, c(1,2)], by.x = c("V2"), by.y = c("OPO"), all.x = T)
    temp = temp[order(temp[, 2]), ]
    temp$cumsum_TC = cumsum(temp$TC_count)

    TC_cnt[which(TC_cnt$OPO == opo), c("min_dist_miles_n_TCs")] = max(temp[which(temp$cumsum_TC >= n)[1], 2], min_dist)
  }  
}
```

# If fixed radian?
```{r}
fixed_rad = 0
```


# Calculate the change in organ share as a function of travel-time/distance:
```{r}
Sys.time()

# First
df_rad = data.frame(matrix(ncol = nrow(df_dem) + 1))
colnames(df_rad) = c('donor_rad', df_dem[, 1])

k = 1     # Denotes row number in df_rad
for (donor in df_sup$DSA) {
  temp = as.data.frame(t(df_mea[as.character(df_mea[, 1]) == as.character(donor), ])[-1, ])
  temp[, 1] = as.numeric(as.character(temp[, 1]))
  temp[, 2] = row.names(temp)
  temp = temp[order(temp[, 1]), ]
  
  temp = temp[temp[, 1] <= max_rad, ]   # Centers <= max_rad
  
  rad_lst = sort(unique(ceiling(temp[, 1] * 10)) / 10) # Different for each donor! 
  
  # To impose Minimum # TCs/Radius constraint:
  # if (!(donor %in% c("HIOP", "PRLL"))) {    
  #   rad_lst = rad_lst[rad_lst >= TC_cnt[TC_cnt$OPO == donor, ]$min_dist_miles_n_TCs]
  # }
  
  if (fixed_rad == 1) {
    rad_lst = ceiling(max_rad * 10)/10
  }
  
  # Start writing the rows, 'donor_rad'
  for (rad in rad_lst) {    # In hrs    
    var_name = paste(donor, rad, sep = "_")
    # print (var_name)
    
    # Receiving TCs of this donor at circle radius 'rad':
    recv_DSAs = temp[temp[, 1] <= rad, 2]
    df_rad[k, ] = NA
    df_rad[k, 1] = var_name
    sup = df_sup[df_sup[, 1] == donor, ncol(df_sup)]
    to_dem = df_dem[df_dem[, 1] %in% recv_DSAs, ncol(df_dem)]  # Vector of demands
    for (j in recv_DSAs) {
      if (!(j %in% c("NYWN", "NYAP", "CAGS", "OHLC", "NVLV", "NMOP"))) {    # Remove DSAs with no demand!
        df_rad[k, j] = df_dem[df_dem[, 1] == j, ncol(df_dem)] / sum(to_dem) * sup
      }
    }
    k = k + 1
  }
}

Sys.time()
```

```{r}
# min_dist_donor = data.frame(donor = as.character(df_opo_dist[, 1]), nearest_opo_dist = sapply(c(1:nrow(df_opo_dist)), function(x) {min(df_opo_dist[x, -1] * 1)}))    # In miles, 1.15078 nautical miles
#write.csv(df_rad$donor_rad, "/Users/shubhamakshat/Desktop/test.csv", row.names = F)
```


Function to create 'constraint matix':
```{r}
df_T = function(min_lam, beta_stage) {
  df = data.frame(variable = c())

  donors = as.character(df_sup[, 1]) #[1:4] 
  recipients = as.character(df_dem[, 1]) #[1:4]

  # Enter variables:
  df[1, 1] = paste('lambda')
  row =  nrow(df) + 1
  for (i in df_rad$donor_rad) {
    df[row, 1] = paste("x", i, sep = "_")
    row =  nrow(df) + 1
  }
  
  # Beta row:
  row =  nrow(df) + 1
  if (beta_stage == 1) {
    df[row, 1] = paste('beta')
    row =  nrow(df) + 1
  }
  
  # Assign a row as rhs_sense:
  df[row, 1] = 'rhs_sense'
  rhs_sense = row
  row = row + 1
  
  # Assign last row as RHS row:
  df[row, 1] = 'RHS'
  rhs = row

  # Write Objective function:
  if (beta_stage == 0) {
    row = which(df[, 1] == paste("lambda"))
    df[row, 2] = 1
  } else if (beta_stage == 1) {
    row = which(df[, 1] == paste("beta"))
    df[row, 2] = 1
  }
  
  # Write constraints:
  
  # Constraint 1: Assign only one 'radius' to a donor:
  col = ncol(df) + 1
  for (donor in donors) {
    df[grep(paste("x", donor, sep = "_"), df[, 1]), col] = 1
    df[rhs_sense, col] = "="
    df[rhs, col] = 1
    col = col + 1
  }

    # Constraint 2: s/d ratios at transplant centers...lambdas:
  col = ncol(df) + 1
  for (j in recipients) {
    dj = df_dem[df_dem[, 1] == j, c("dem")]
    
    # List variables that are associated with postive organ supply to this Center:
    j_lst = df_rad[!is.na(df_rad[, j]), 1] 
    
    for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"
      donor = substr(var, start = 1, stop = 4)
      rad = as.numeric(strsplit(var, "_")[[1]][2])    # In hrs/distance(miles??)
      
      row = which(df[, 1] == paste('x', var, sep = "_"))
      df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific radius
    }
    row_lam = which(df[, 1] == paste("lambda"))
    df[row_lam, col] = -1   # Corresponds to 'lambda'
    df[rhs_sense, col] = ">="
    df[rhs, col] = 0
    col = col + 1
  }
  
  # Constraint 3: s/d ratios at transplant center for BETA stage:
  if (beta_stage == 1) { ##| (alpha_stage == 1)) {
    
    col = ncol(df) + 1
    for (j in recipients) {
      dj = df_dem[df_dem[, 1] == j, c("dem")]
      
      # List variables that are associated with postive organ supply to this Center:
      j_lst = df_rad[!is.na(df_rad[, j]), 1] 
      
      for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"
        donor = substr(var, start = 1, stop = 4)
        rad = as.numeric(strsplit(var, "_")[[1]][2])    # In hrs
        
        row = which(df[, 1] == paste('x', var, sep = "_"))
        df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific radius
      }
      df[which(df[, 1] == "beta"), col] = -1   # Corresponds to 'beta'
      df[rhs_sense, col] = "<="
      df[rhs, col] = 0
      col = col + 1
    }
  }
  
  # Min_lam / Max_alpha / Max_beta constraints:
  col = ncol(df) + 1
  if (beta_stage == 0) {
    # row = which(df[, 1] == paste("lambda"))
    # df[row, col] = 1
    # df[rhs_sense, col] = ">="
    # df[rhs, col] = 0
  } else if (beta_stage == 1) {
    row = which(df[, 1] == paste("lambda"))
    df[row, col] = 1
    df[rhs_sense, col] = ">="
    df[rhs, col] = min_lam   # Min_lam constraint
  }
  
  return (t(df))
}
```

```{r}
Sys.time()
min_lam = NA; beta_stage = 0
min_lam = 0.59; beta_stage = 1

df = as.data.frame(df_T(min_lam, beta_stage))
Sys.time()
```

```{r}
# write.csv(df, "/Users/shubhamakshat/Desktop/test_2.csv", row.names = F, na = "")
```

```{r}
Sys.time()
model = list()
A = as.matrix(df[3:nrow(df), 1:(ncol(df) - 2)])
A = data.frame(sapply(data.frame(A), function(x) as.numeric(as.character(x))))
A[is.na(A) ] = 0
A = as.matrix(A)
model$A = A

variables = head(as.character(unlist(df[1, ])), -2) # print (variables)
model$sense = as.character(unlist(df[3:nrow(df), (ncol(df)-1)])) # print (sense)
model$rhs = as.numeric(as.character(df[3:nrow(df), ncol(df)]))
model$obj = head(as.numeric(as.character(unlist(df[2,]))), -2) # as.numeric(df[c(1:(nrow(df)-2)), 2])
model$obj[is.na(model$obj)] = 0
model$vtype = c('C', rep('B', length(grep('x_', as.character(unlist(df[1, ]))))))

if (beta_stage == 0) {
    model$modelsense = "max"
  } else if (beta_stage == 1) {
    model$vtype = c(model$vtype, "C")
    model$modelsense = "min"
  }
Sys.time()
```


```{r}
# MIP focus:
# MIPFocus=1 : Find feasible solutions quickly,
# MIPFocus=2 : Focus more attention on proving optimality,
# MIPFocus=3 : To focus on the bound, if the best objective bound is moving very slowly (or not at all)
```

```{r}
Sys.time()

#temp = read.csv("/Users/sakshat/Google Drive/Health Care/Optimized Overlapping Organ Allocation/DSA_based_files/Set Partioning/result_SetPart_700nmi_beta_1_lam_0.53_min_dist_150nmi_min_TC_3_MIP_1per.csv")
#length(model$vtype)
#model$start = c(temp$result.x[-nrow(temp)], rep(NA, 52*2), temp$result.x[nrow(temp)])
#model$start = c(temp$result.x)
#model$start = c(result$x, 15)
model$start = c(result$x)

mip_gap = 0.0001
params = list(MIPFocus = 3, TimeLimit = 3600* 4,
                    FeasibilityTol = 1e-6, IntFeasTol = 1e-9, MIPGap = mip_gap, OptimalityTol = 1e-6,
                    ObjScale = -0.5, ScaleFlag = 0, Heuristics = 0.05, Cuts = -1,
                    Presolve = 2, PreSparsify = 0, NumericFocus = 1, Aggregate = 0)

result = gurobi(model, params)
Sys.time()
```


```{r}
sum(df_sup$sup) / sum(df_dem$dem)

if (beta_stage == 0) {
  fil_name = paste0("SP_", val, ifelse(mea == "dist", "NM_", "hr_"), "beta_", beta_stage)
} else if (beta_stage == 1) {
  fil_name = paste0("SP_", val, ifelse(mea == "dist", "NM_", "hr_"), "beta_", beta_stage)
}

write.csv(data.frame(variables, result$x, model$obj), paste0(fol_, "/SRTR/Het_circles/result_", fil_name, ".csv"), row.names = F)
```

# To create LSAM input file using the 'result':
```{r}
create_NEIGH_file_frm_circles_out = function(circles_out, df_mea) {
  
  df_out = expand.grid(main_DSA = unique(df_sup$DSA), recv_DSA = unique(df_dem$DSA))
  df_out$in_neigh = 0
  for (i in c(1:nrow(circles_out))) {
    
    main_dsa = strsplit((circles_out[, 1][i]), "_")[[1]][2]
    rad = as.numeric(strsplit((circles_out[, 1][i]), "_")[[1]][3])
  
    temp = as.data.frame(t(df_mea[as.character(df_mea[, 1]) == as.character(main_dsa), ])[-1, ])
    temp[, 1] = as.numeric(as.character(temp[, 1]))
    temp[, 2] = row.names(temp)
    receiving_dsas = temp[temp[, 1] <= rad, 2]
    
    cond = (df_out$main_DSA == main_dsa) & (df_out$recv_DSA %in% receiving_dsas)
    df_out[cond, "in_neigh"] = 1
  }
  df_out = df_out[df_out$in_neigh == 1, ]
  return (df_out)
}
```

```{r}

circles_out = data.frame(variables, result$x)
circles_out = circles_out[circles_out[, 2] == 1, ]
circles_out[, 1] = as.character(circles_out[, 1])

temp = create_NEIGH_file_frm_circles_out(circles_out, df_mea = df_opo_dist)

write.csv(temp, paste0(fol_, "/SRTR/Het_circles/neigh_", fil_name, ".csv"), row.names = F)
```

```{r}
fetch_val = function(opo1, opo2, df1) {   # Assuming symmetric values
  row_opo1 = which(df1[, 1]==opo1)
  #row_opo2 = which(df1[, 1]==opo2)
  val = df1[row_opo1, opo2]   
  return (as.numeric(val))
}


```

```{r}
#write.csv(df_sup, "/Users/shubhamakshat/Desktop/sup.csv", row.names = F)
```

```{r}

```

```{r}

```

