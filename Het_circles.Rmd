
```{r}
library(data.table)
library(Matrix)
library(gurobi)
library(readxl)
library(stringr)
library(mltools)
library(ggplot2)
library(geosphere)
library(pracma)
library(parallel)
```

# This file uses "Donor Hospitals" and "TCs" to in s/d calculations:
```{r}
computer = "imac" # mac, imac, windows

if (computer == "imac") {
  fol = paste0("/Users/sakshat/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "/Users/sakshat/Google Drive/"
} else if (computer == "mac") {
  fol = paste0("/Users/shubham/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "/Users/shubham/Google Drive/"
} else if (computer == "windows") {
  fol = paste0("C:/Users/sakshat/Google Drive/SRTR/R_files/Equilibrium/Input_data/Nation")
  fol_ = "C:/Users/sakshat/Google Drive/"
}
```

```{r}
fixed_rad = 0

sim_based = 1     # Sim. based if demand and supply are based on simulation setup, else it uses the full dataset.
```

# Supply and demand data (9 years):
### VVI: Not considering MELD>=15 patients:
```{r}
if (sim_based == 0) {
  df_dem = read_excel(paste0(fol_, "/SRTR/R_files/Equilibrium/Input_data/For_Gurobi/dem_sup.xlsx"), sheet = "dem")
  df_sup = read_excel(paste0(fol_, "/SRTR/R_files/Equilibrium/Input_data/For_Gurobi/dem_sup.xlsx"), sheet = "sup")
  
  # 2015-18:
  df_dem$dem = df_dem$`dem_2015-18`
  df_sup$sup = df_sup$`sup_2015-18`
  sum(df_sup$sup)/sum(df_dem$dem)
  
  df_dem = df_dem[df_dem$dem > 0, ]
  df_sup = df_sup[df_sup$sup > 0, ]
}
```

```{r}
if (sim_based == 1) {
  can_pool_master = read.csv(paste0(fol, "/can_pool_master_2yrs_5000_pats.csv"), stringsAsFactors = F)
  don1 = read.csv(paste0(fol, "/don1_3600.csv"), stringsAsFactors = F)
  
  df_dem = data.table(can_pool_master)[, list(dem = uniqueN(PX_ID)), by = list(TC)]
  colnames(df_dem)[1] = "transplant_center"
  
  # Remove 'HISF' and 'HIQM':
  df_dem = df_dem[!df_dem$transplant_center %in% c("HISF", "HIQM"), ]
  
  df_sup = data.table(don1)[, list(sup = uniqueN(DONOR_ID)), by = list(don_hosp_id)]
  #temp = temp[!temp$DON_OPO_CTR_CD %in% c("ZCAN", "WISE")]    # sum(temp$sup)
}
```


```{r}
df_donor_trnspl_dist = read.csv(paste0(fol_, '/SRTR/Analysis/dist_matrix_don_hosp_txc.csv'), stringsAsFactors = F)

setdiff(df_dem$transplant_center, colnames(df_donor_trnspl_dist))
setdiff(df_sup$don_hosp_id, df_donor_trnspl_dist$X__1)

# Only Donor hospitals which have >0 supply:
df_donor_trnspl_dist = df_donor_trnspl_dist[(df_donor_trnspl_dist$X__1 %in% df_sup$don_hosp_id), ]

# Only TCs which have >0 demand:
df_donor_trnspl_dist = df_donor_trnspl_dist[, c(1, which(colnames(df_donor_trnspl_dist) %in% df_dem$transplant_center))]
```

# To shift ALASKA donor hospitals to SEA (-122.30602, 47.45052), and update the distance matrix:
```{r}
# Already done in 'Distance_matrix.R' file
```

# Analysis of "Donor - Transplant centre" distances:
```{r}
transplant_centres = unlist(as.data.frame(df_dem)[, 1])
  
# Number of Donor hospitals to a transplant centre within "ub_d" miles:
max_rad = 600 # In 'nautical miles'

ub_d = max_rad  * 1.609 * 1.15078
temp = data.frame(transplant_centres, cnt_donors = NA)
temp$cnt_donors = sapply(transplant_centres, function(x) {sum(df_donor_trnspl_dist[, x] < ub_d)})
row.names(temp) = c(1:nrow(temp))

# Number of transplant centres to a Donor hospital within "ub_d" miles:
temp2 = data.frame(df_donor_trnspl_dist[, 1], cnt_t_centres = NA)
temp2$cnt_t_centres = sapply(c(1:nrow(df_donor_trnspl_dist)), function(x) {sum(df_donor_trnspl_dist[x, -1] < ub_d)})
```

```{r}
# Remove 'donors' who donot have any centre within 'ub_d':
donor_no_neigh = temp2[which(temp2[, 2] == 0), 1]

print (as.character(donor_no_neigh))
discarded_donors_supply = sum(df_sup[which(unlist(df_sup[, 1]) %in% donor_no_neigh), c("sup")])
print (paste("Supply @ Donor hospitals", length(donor_no_neigh), "with far off Txc: ", discarded_donors_supply))

if (length(donor_no_neigh) > 0) {
  df_sup = df_sup[-c(which(unlist(df_sup[, 1]) %in% donor_no_neigh)), ]
  df_donor_trnspl_dist = df_donor_trnspl_dist[-c(which(unlist(df_donor_trnspl_dist[, 1]) %in% donor_no_neigh)), ]
}

# Remove 'centres' who have 0 or very few donors within 'ub_d':
centre_few_neigh = temp[which(temp[, 2] < 1), 1]
if (length(centre_few_neigh) > 0) {
  verify below lines!!
  df_dem = df_dem[-c(which(df_dem[, 1] %in% centre_few_neigh)), ]
  df_donor_trnspl_dist = df_donor_trnspl_dist[, -which(names(df_donor_trnspl_dist) %in% centre_few_neigh)]
}

```

# Calculate the organ share as a function of distance:
```{r}
Sys.time()

df_rad = data.frame(matrix(ncol = nrow(df_dem) + 1))
colnames(df_rad) = c('donor_rad', df_dem$transplant_center)

min_rad = 150 # In nautical miles

f_alloc = function(donor) {
  temp = as.data.frame(t(df_donor_trnspl_dist[as.character(df_donor_trnspl_dist[, 1]) == as.character(donor), ])[-1, ])
  temp[, 1] = as.numeric(as.character(temp[, 1]))
  temp[, 2] = row.names(temp)
  
  temp = temp[temp[, 1] <= max_rad * 1.609 * 1.15078, ]   # Centers <= max_rad_
  
  rad_lst = sort(unique(ceiling(temp[, 1]) + 1)) # Different for each donor!  
  
  if (max(rad_lst) > min_rad * 1.609 * 1.15078) {
    rad_lst = rad_lst[rad_lst >= min_rad * 1.609 * 1.15078]
    if(fixed_rad == 1) {rad_lst = rad_lst[length(rad_lst)]}
  } else {
    # Retain only the maximum radius!, 
    rad_lst = rad_lst[length(rad_lst)]
    print (paste0(donor, ": NO TCs in the range [150 NM, max_rad]...although there can be >=3 TC within 150NM!"))
  }

  df_rad_temp = data.frame(matrix(ncol = nrow(df_dem) + 1))
  colnames(df_rad_temp) = c('donor_rad', df_dem$transplant_center)
  k = 1
    #return (df_rad_temp)
  # Start writing the rows, 'donor_rad'
  for (rad in rad_lst) {    # In miles
    var_name = paste(donor, rad, sep = "_")

    # Receiving TCs of this donor at circle radius 'rad':
    recv_TCs = temp[temp[, 1] < rad, 2]
    
    df_rad_temp[k, 1] = var_name
    sup = df_sup[which(df_sup[, 1] == donor), ]$sup
    to_dem = df_dem[which(df_dem$transplant_center %in% recv_TCs), ]$dem  # Vector of demands
    for (j in recv_TCs) {
      df_rad_temp[k, j] = df_dem[which(df_dem[, 1] == j), "dem"] / sum(to_dem) * sup
    }
    k = k + 1
  }
  return (df_rad_temp)
}

#out = lapply(df_sup$don_hosp_id, f_alloc)
out = mclapply(df_sup$don_hosp_id, f_alloc)

for (i in c(1:length(out))) {
  df_rad = rbind(df_rad, out[i][[1]])
}
    
# temp = f_alloc(donor)
# temp = out[2][[1]]

Sys.time()

df_rad = df_rad[-1, ]

# write.csv(df_rad, paste0(fol_, "/SRTR/Het_circles/df_rad_", ifelse(sim_based == 1, "SIM_based_", ""), max_rad, ".csv"), row.names = F)
```


```{r}
df_rad = read.csv(paste0(fol_, "/SRTR/Het_circles/df_rad_", ifelse(sim_based == 1, "SIM_based_", ""), max_rad, ".csv"), stringsAsFactors = F)

max(as.numeric(sapply(c(1:nrow(df_rad)), function(i) {str_split(df_rad$donor_rad[i], "_")[[1]][2]}))) / (1.609 * 1.15078)
```

# Optimization:
# Function to create 'constraint matix':
```{r}
df_T = function(min_lam, beta_stage) {
  df = data.frame(variable = c())
  
  donor_clstrs = as.character(unlist(df_sup[, 1])) #[1:4] 
  transplant_centres = as.character(unlist(df_dem[, 1])) #[1:4]
  
  #min_dist_donor = data.frame(donor = as.character(df_donor_trnspl_dist[, 1]), nearest_TC_dist = sapply(c(1:nrow(df_donor_trnspl_dist)), function(x) {min(df_donor_trnspl_dist[x, -1]) / (1.609 * 1.15078)}))    # In nautical miles
  
  # Enter variables:
  df[1, 1] = paste('lambda')
  row =  nrow(df) + 1
  df[c(row:(length(df_rad$donor_rad) + 1)), 1] = paste("x", df_rad$donor_rad, sep = "_")
  
  # Beta row:
  row =  nrow(df) + 1
  if (beta_stage == 1) {
    df[row, 1] = paste('beta')
    row =  nrow(df) + 1
  }

  # Assign a row as rhs_sense:
  df[row, 1] = 'rhs_sense'
  rhs_sense = row
  row = row + 1
  
  # Assign last row as RHS row:
  df[row, 1] = 'RHS'
  rhs = row
  
  # Write Objective function:
  if (beta_stage == 0) {
    row = which(df[, 1] == paste("lambda"))
    df[row, 2] = 1
  } else if (beta_stage == 1) {
    row = which(df[, 1] == paste("beta"))
    df[row, 2] = 1
  } 
  
  # Write constraints:
  
  # Constraint 1: Assign only one 'y intercept' to a donor:
  col = ncol(df) + 1
  for (donor in donor_clstrs) {
    #row = which(df[, 1] == paste('x', i, sep = "_"))
    df[grep(donor, df[, 1]), col] = 1
    df[rhs_sense, col] = "="
    df[rhs, col] = 1
    col = col + 1
  }

  # Constraint 2: s/d ratios at transplant centers...lambdas:
  col = ncol(df) + 1
  row_lam = which(df[, 1] == paste("lambda"))
  for (j in transplant_centres) {
    dj = as.numeric(df_dem[df_dem$transplant_center == j, c("dem")])
    
    # List variables that are associated with postive organ supply to this Center:
    j_lst = df_rad[!is.na(df_rad[, j]), 1] 
    
    for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"
      
      row = which(df[, 1] == paste('x', var, sep = "_"))
      df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific 'y'
    }
    df[row_lam, col] = -1   # Corresponds to 'lambda'
    df[rhs_sense, col] = ">="
    df[rhs, col] = 0
    col = col + 1
  }
  
  # Constraint 3: s/d ratios at transplant center for BETA stage:
  if (beta_stage == 1) { ##| (stage3 == 1)) {
  
  col = ncol(df) + 1
  row_beta = which(df[, 1] == paste("beta"))
  for (j in transplant_centres) {
    dj = df_dem[df_dem$transplant_center == j, c("dem")]
    
    # List variables that are associated with postive organ supply to this Center:
    j_lst = df_rad[!is.na(df_rad[, j]), 1] 
    
    for (var in j_lst) {     # Looping only on variables in j_lst, var is of the form: "C_24_718"

      row = which(df[, 1] == paste('x', var, sep = "_"))
      df[row, col] =  df_rad[df_rad[, 1] == var, j] / dj   # Supply from a donor for a specific radius
      }
    df[row_beta, col] = -1   # Corresponds to 'beta'
    df[rhs_sense, col] = "<="
    df[rhs, col] = 0
    col = col + 1
    }
  }

  # Min_lam /Max_beta constraints:
  col = ncol(df) + 1
  if (beta_stage == 1) {
    row = which(df[, 1] == paste("lambda"))
    df[row, col] = 1
    df[rhs_sense, col] = ">="
    df[rhs, col] = min_lam   # Min_lam constraint
  } 
 
  return (t(df))
}
```

```{r}
Sys.time()
min_lam = NA; beta_stage = 0    # 40 mins
min_lam = 0.63; beta_stage = 1    # 90 mins

df = as.data.frame(df_T(min_lam, beta_stage))
Sys.time()
```


```{r}
Sys.time()     # 5 mins
model = list()
A = as.matrix(df[3:nrow(df), 1:(ncol(df) - 2)])
A = data.frame(sapply(data.frame(A), function(x) as.numeric(as.character(x))))
A[is.na(A) ] = 0
A = as.matrix(A)
model$A = as(A, "sparseMatrix")

variables = head(as.character(unlist(df[1, ])), -2) # print (variables)
model$sense = as.character(unlist(df[3:nrow(df), (ncol(df)-1)])) # print (sense)
model$rhs = as.numeric(as.character(df[3:nrow(df), ncol(df)]))
model$obj = head(as.numeric(as.character(unlist(df[2,]))), -2) # as.numeric(df[c(1:(nrow(df)-2)), 2])
model$obj[is.na(model$obj)] = 0
model$vtype = c('C', rep('B', length(grep('x_', as.character(unlist(df[1, ]))))))

if (beta_stage == 0) {
    model$modelsense = "max"
  } else if (beta_stage == 1) {
    model$vtype = c(model$vtype, "C")
    model$modelsense = "min"
  }
Sys.time()
```

# If want to change "min_lam":
```{r}
# Index for 'min_lam':
model$rhs[which(0.50 == model$rhs)] = 0.00
```


```{r}
Sys.time()

#temp = read.csv("/Volumes/GoogleDrive/My Drive/Health Care/Optimized Overlapping Organ Allocation/ZIP_models/ub_d_600/result_4dgt_circles_600NM_beta_1_alph_0_lam_0.54_min_dst_150NM_min_TC_3.csv")
#model$start = c(result$x[-(length(result$x))])
#model$start = c(result$x, 3)
model$start = result$x

mip_gap = 0.0001
params = list(MIPFocus = 3, TimeLimit = 360*10, #3600 * 2.5,
                    FeasibilityTol = 1e-6, IntFeasTol = 1e-9, MIPGap = mip_gap, OptimalityTol = 1e-6,
                    ObjScale = -0.5, ScaleFlag = 0, Heuristics = 0.05, Cuts = 0,
                    Presolve = 2, PreSparsify = 0, NumericFocus = 1, Aggregate = 0)

result = gurobi(model, params)
Sys.time()
```

# Write the result:
```{r}
# temp = data.frame(variables, result$x)
write.csv(data.frame(variables, result$x), paste0(fol_, "/SRTR/Het_circles/", "result_", ifelse(sim_based == 1, "SIM_based_", ""), max_rad, ifelse(beta_stage == 1, "beta1.csv", ".csv")), row.names = F)
```

#########




```{r}
fetch_val = function(cluster1, cluster2_or_transplant_centre, df1) {   # Assuming symmetric values
  row_cluster1 = which(df1[, 1] == cluster1)
  val = df1[row_cluster1, cluster2_or_transplant_centre]
  return (as.numeric(val))
}
```

```{r}
discarded_donors_supply = 0

cal_lambdas = function() {    # result_df_name
  
  #result_df = read.csv(result_df_name)   # data.frame(variables, result$x)
  result_df = data.frame(variables, result$x)
  result_df[, 1] = as.character(result_df[, 1])
  
  # Specify demand column: NOTE: LAST Column is the demand column
  dem_col = df_dem[, "dem"]
  # Specify supply column: NOTE: LAST Column is the supply column
  sup_col = df_sup[, "sup"]
  
  donor_clstrs = df_sup$don_hosp_id
  transplant_centres = df_dem$transplant_center
  
  dem = c(); sup = c()
  sup_loc_cnt = c()
  lambda = c()
  min_prox_score = c()
  avg_prox_score = c()
  max_prox_score = c()
  
  result_df = result_df[(grep('x_', result_df[, 1]) ), ]
  result_df = result_df[result_df[, 2]==1, ]
  don_rad = substring(result_df[, 1], 3)    # Removing first 2 characters: "x_"
  
  df_rad_x = df_rad[df_rad[, 1] %in% don_rad, ]
  
  for (j in transplant_centres) {
    temp = df_rad_x[!is.na(df_rad_x[, j]), c("donor_rad", j)]
    sup_loc_cnt = c(sup_loc_cnt, nrow(temp))
    dem_j = df_dem[df_dem$transplant_center == j, ]$dem; dem = c(dem, dem_j)
    supply_j = sum(temp[, 2]) + (dem_j / sum(dem_col) * discarded_donors_supply); sup = c(sup, supply_j)
    lambda = c(lambda, supply_j / dem_j)
    # temp[, 1] = as.character(temp[, 1]); colnames(temp)[2] = "TC"
    # 
    # # To calculate the max_prox_score:
    # 
    # temp = merge(temp, df_donor_trnspl_dist[, c("X__1", j)], by.x = "donor", by.y = "X__1")
    # temp[, j] = temp[, j] / (1.609 * 1.15078)
    # temp$y = as.numeric(sapply(c(1:nrow(temp)), function(i) {strsplit(temp$donor_y[i], split = "_")[[1]][3]}))
    # temp$prox_score = ceiling(temp$y - (temp$y/max_rad) * temp[, j])
    # min_prox_score = c(min_prox_score, min(temp$prox_score))
    # avg_prox_score = c(avg_prox_score, mean(temp$prox_score))
    # max_prox_score = c(max_prox_score, max(temp$prox_score))
  }
  
  # return (data.frame(transplant_centres, dem, sup_loc_cnt, min_prox_score, avg_prox_score, max_prox_score, lambda))
  return (data.frame(transplant_centres, dem, sup, sup_loc_cnt, lambda))
}
```


```{r}
discarded_donors_supply=0

# fil_name = paste0("result_COM3dgt_1000y1_20_p0.025beta1_alaska_MIP0.22per", ".csv")
# lambdas = cal_lambdas(result_df_name = paste0(fol_, fil_name, sep = ""))

lambdas = cal_lambdas()
```

# Write the files:
```{r}
# "df_rad_x" is the df_rad corresponding to variable = 1!
write.csv(df_rad_x, paste0(fol_, "/SRTR/Het_circles/", "df_rad_x_", max_rad, ifelse(beta_stage == 1, "beta1.csv", ".csv")), row.names = F)
write.csv(lambdas, paste0(fol_, "/SRTR/Het_circles/", "lambdas_", max_rad, ifelse(beta_stage == 1, "beta1.csv", ".csv")), row.names = F)
```

```{r}
create_NEIGH_file_frm_circles_out = function(circles_out, df_mea) {
  
  df_out = expand.grid(don_hosp_id = unique(df_sup$don_hosp_id), recv_TC = unique(df_dem$transplant_center))
  df_out$in_neigh = 0
  for (i in c(1:nrow(circles_out))) {
    
    don_hosp = strsplit((circles_out[, 1][i]), "_")[[1]][2]
    rad = as.numeric(strsplit((circles_out[, 1][i]), "_")[[1]][3])
  
    temp = as.data.frame(t(df_mea[as.character(df_mea[, 1]) == as.character(don_hosp), ])[-1, ])
    temp[, 1] = as.numeric(as.character(temp[, 1]))
    temp[, 2] = row.names(temp)
    receiving_TCs = temp[temp[, 1] <= rad, 2]
    
    cond = (df_out$don_hosp_id == don_hosp) & (df_out$recv_TC %in% receiving_TCs)
    df_out[cond, "in_neigh"] = 1
  }
  df_out = df_out[df_out$in_neigh == 1, ]
  return (df_out)
}
```

```{r}

circles_out = data.frame(variables, result$x)
circles_out = circles_out[circles_out[, 2] == 1, ]
circles_out[, 1] = as.character(circles_out[, 1])

temp = create_NEIGH_file_frm_circles_out(circles_out, df_mea = df_donor_trnspl_dist)

write.csv(temp, paste0(fol_, "/SRTR/Het_circles/neigh_", ifelse(sim_based == 1, "SIM_based_", ""), max_rad, ifelse(beta_stage == 1, "beta1.csv", ".csv")), row.names = F)
```



# Write the file:
```{r}
write.csv(lambdas, paste0("lam_COM", zip_cluster, "dgt_" , max_rad, "y", min(y_lst), "_", max(y_lst), "_p", p_acpt, ifelse(beta_stage == 1, "beta1_alaska.csv", "_alaska.csv")), row.names = F)

m = lm(lambda ~ dem + avg_prox_score + sup_loc_cnt, data = lambdas); summary(m)
m = lm(avg_prox_score ~ dem + lambda + sup_loc_cnt, data = lambdas); summary(m)
cor(lambdas$avg_prox_score, lambdas$sup_loc_cnt)   # If more no. of supply locations are there, then not much need to SHIFT (to right) MELD at the TC.
cor(lambdas$avg_prox_score, lambdas$lambda)   # Why negative relationship?
```













